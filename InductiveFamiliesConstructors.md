# Remarks on the constructors of indutive families of types

I finally figured out what constructors when defining an inductive families of types.

The code snippets I wrote today is

```agda
 data HasBH : Tree → Nat → Set where
        HBH-Empty : HasBH Empty 1

      
        HBH-Node-Red : (n : Nat) → (l : Tree) → (r : Tree) → (kv : Key × Value)
                       → HasBH l n
                       → HasBH r n
                       → HasBH (Node l Red kv r) n
                       
        HBH-Node-Black : (n : Nat) → (l : Tree) → (r : Tree) → (kv : Key × Value)
                       → HasBH l n
                       → HasBH r n
                       → HasBH (Node l Red kv r) (S n)

```

following OPLSS 2013 lecture by professor Dan Licata on agda.

where `Tree` is defined as follows

```agda
  module RBT (Key : Set) (compare : Key → Key → Order) (Value : Set) where 

    data Color : Set where
      Red : Color
      Black : Color
  
    data Tree : Set where
      Empty : Tree
      Node : Tree → Color → (Key × Value) → Tree → Tree
```

There are several different ways of interpreting this code snippets that I find helpful to aid understanding.

I find professor Dan Licata's comments extremely helpful to understand. He said something along the lines of

"What `HasHB` does is that it is defining a family of types indexed over Tree and Nat by simultaneouly induction."

`##TODO: find the original quote, approximately at 35 minutes of first lecture."

We are defining a dependent function, or a family of types by induction simultaneously. We may further inquire 
how did we define them?

IN Coq, the calculus of inductive construction, the definition is defined by providing the induciton principle 
fro a type. For example, when we are defining natural nubmers, we are actually defining induction principle for 
natural numbers (i.e. mathematical induciton). But what are induction principles?

They are nothing but a term that has a certain type. By the famous curry-howard isomorphism, it is same as saying
that certain proposition has a proof. So when we are defining the induciton principle over natural numbers, what 
we are actually saying is that the induction principle has a proof. 

So similarly, what are those "HBH-*"s that we have written in the beginning? They are 
dependent functions that returns terms of the a certain type, which is generated by applying the inductive families of types
over certain arguments. But they are also saying that there are certain true propositions, and those propositions are proved by 
the "HBH-*" themselves. That is, each "HBH-*" proves a true proposiiton.

This is my first draft. I didn't proof read this. I will do the proof read later.

# Update

Inductive families correspond to system of inference rules. (OPLSS 2013 agda 1 at 27:00)

Use of inversion in agda (OPLSS 2013 agda 1 at 59:00)

Dependent pattern matching is the unification of constructors with things you have. (OPLSS 2013 agda 2 at 3:57)

Inversion is the process of defining constructor arguments in terms of other stuff. (OPLSS 2013 agda 2.1 at 8:22)

With: In agda, "this is magic, when you do a with, agda takes the context and the goal and replaces all occurances of the term that you are doing the with on (in this case compare k k') with the variable or patterns that you conclude (use) in the cases of the pattern match. So you are wripping out compare k k',  and saying let's replace that with something else, you use rewriting in Coq to accomplish something like this. (OPLSS 2013 agda 2.2 at 5:00)

Inductively defined universe = A type of things + A function that for each thing, gives you an agda type (OPLSS 2013 agda 3.2 at 01:10)

"Inductive Recursive Universes isolate a set of types" (OPLSS 2013 agda 4.1 at 6:35)

"When you're proving that things are equal, you're proving that things are interchangeable in all contexts" (OPLSS 2013 agda 5.1 21:33)

"Nat cross Nat is equal (in the double equal sense) to Nat cross Nat. This proof of equality is not reflexivity. This is a different way of showing that these types are equal than reflexivity. When you take the swap function and turn it into equality, you are still preserving the fact that it behaves differently than reflexivity. (Computationally relevant proofs of equality) " (OPLSS 2013 agda 5.1 24:18)
